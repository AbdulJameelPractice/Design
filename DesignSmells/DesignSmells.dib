#!markdown

##### Imperative Abstraction - classes with single method and fallows more procedural apporach 

 

#!csharp

using static System.Console;

#!csharp

public class Calculation
{
    public int CalculateOffset() // contain single method and created based on the action performendd
    {
        WriteLine("CalculateOffset");
       return -1;
    }
}

public class SaveOffsetHandler
{
    public void SaveOffset(int i)
    {
        WriteLine("SaveOffset");
    }
}

public class Application
{
    
    public void CalculateAndPrint()
    {
    Calculation c = new Calculation();
    SaveOffsetHandler handler=new SaveOffsetHandler();
    c.CalculateOffset();
    handler.SaveOffset(10);
    }
}

Application app = new ();
app.CalculateAndPrint();

#!csharp

public class ImagePair
{
    public int CalculateOffset() 
    {
        WriteLine("CalculateOffset");
       return -1;
    }

    public void SaveOffset(int i)
    {
        WriteLine("SaveOffset");
    }
}

public class Application
{
    public void CalculateAndPrint()
    {
        ImagePair c = new ImagePair();
        c.CalculateOffset();
        c.SaveOffset(10);
    }
}

Application app = new ();
app.CalculateAndPrint();

#!markdown

##### Missing Abstraction  - the smell arises when clumpses of data or encoded strings are used instead of a class or interface
`e.g` ISBN number as string 

#!csharp

// Provide crisp and conceptual boundaries and a unique identity‚Äù
public class ISBN
{
    public string IsbnString {get;set;}
    public string GroupNumber {get;set;}
}

#!markdown

##### Untilized Abstraction - abstraction is left unused
 - e.g method or classes left unused

#!markdown

##### Incomplete abstraction
 - car with accelrator but without brake.
 - abstract factory to create items method but not to delete the items

#!markdown

##### Unnecessary Abstractions
- e.g Best Seller book extends Book, instead we can have a Book with IsBestSeller Property
